C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.obj
COMPILER INVOKED BY: C:\Keil_v51\C51\BIN\C51.EXE source\main.c LARGE RTX51 BROWSE DEBUG OBJECTEXTEND PRINT(.\main.lst) T
                    -ABS(2) OBJECT(main.obj)

line level    source

   1          
   2          // å­—ç¬¦ç¼–ç ä½¿ç”¨ UTF-8
   3          #include "ADC.h"
   4          #include "DAC.h"
   5          #include "Delay.h"
   6          #include "SYS_Init.h"
   7          #include "Timer.h"
   8          #include "led.h"
   9          #include "lcd.h" 
  10          // #include "Handle_Menu.h"
  11          #include "c8051f020.h"
  12          #include <math.h>
  13          #include <stdlib.h>
  14          #define NB -3
  15          #define NM -2
  16          #define NS -1
  17          #define ZO 0
  18          #define PS 1
  19          #define PM 2
  20          #define PB 3
  21          
  22          void FuzzyPID();  //åˆå§‹åŒ–PIDå‚æ•°
  23          float FuzzyPIDcontroller(float e_max, float e_min, float ec_max, float ec_min, float kp_max, float kp_min,
             - float error, float error_c, float ki_max, float ki_min,float kd_max, float kd_min,float error_pre, float error_ppre);  
             -//æ¨¡ç³ŠPIDæ§åˆ¶å®ç°å‡½æ•°
  24          float Quantization(float maximum, float minimum, float x);  //è¯¯å·® error å’Œè¯¯å·®å˜åŒ– error_c æ˜ å°„åˆ
             -°è®ºåŸŸä¸­çš„å‡½æ•°
  25          void Get_grad_membership(float error, float error_c); ////è®¡ç®—è¾“å…¥eä¸de/dtéš¶å±åº¦
  26          void GetSumGrad();// è·å–è¾“å‡ºå¢é‡ â–³kpã€â–³kiã€â–³kd çš„æ€»éš¶å±åº¦
  27          void GetOUT();  // è®¡ç®—è¾“å‡ºå¢é‡ â–³kpã€â–³kiã€â–³kd å¯¹åº”è®ºåŸŸå€¼
  28          float Inverse_quantization(float maximum, float minimum, float qvalues);  //å»æ¨¡ç³ŠåŒ–
  29          
  30          
  31          const int  num_area = 8; //åˆ’åˆ†åŒºåŸŸä¸ªæ•°
  32          float e_membership_values[7] = {-3,-2,-1,0,1,2,3}; //è¾“å…¥eçš„éš¶å±å€¼
  33          float ec_membership_values[7] = { -3,-2,-1,0,1,2,3 };//è¾“å…¥de/dtçš„éš¶å±å€¼
  34          float kp_menbership_values[7] = { -3,-2,-1,0,1,2,3 };//è¾“å‡ºå¢é‡kpçš„éš¶å±å€¼
  35          float ki_menbership_values[7] = { -3,-2,-1,0,1,2,3 }; //è¾“å‡ºå¢é‡kiçš„éš¶å±å€¼
  36          float kd_menbership_values[7] = { -3,-2,-1,0,1,2,3 };  //è¾“å‡ºå¢é‡kdçš„éš¶å±å€¼
  37          
  38          float kp;                       //PIDå‚æ•°kp
  39          float ki;                       //PIDå‚æ•°ki
  40          float kd;                       //PIDå‚æ•°kd
  41          float qdetail_kp;               //å¢é‡kpå¯¹åº”è®ºåŸŸä¸­çš„å€¼
  42          float qdetail_ki;               //å¢é‡kiå¯¹åº”è®ºåŸŸä¸­çš„å€¼
  43          float qdetail_kd;               //å¢é‡kdå¯¹åº”è®ºåŸŸä¸­çš„å€¼
  44          float detail_kp;                //è¾“å‡ºå¢é‡kp
  45          float detail_ki;                //è¾“å‡ºå¢é‡ki
  46          float detail_kd;                //è¾“å‡ºå¢é‡kd
  47          float qerror;                    //è¾“å…¥eå¯¹åº”è®ºåŸŸä¸­çš„å€¼
  48          float qerror_c;                  //è¾“å…¥de/dtå¯¹åº”è®ºåŸŸä¸­çš„å€¼             
  49          float e_gradmembership[2];      //è¾“å…¥eçš„éš¶å±åº¦
  50          float ec_gradmembership[2];     //è¾“å…¥de/dtçš„éš¶å±åº¦
  51          int e_grad_index[2];            //è¾“å…¥eéš¶å±åº¦åœ¨è§„åˆ™è¡¨çš„ç´¢å¼•
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 2   

  52          int ec_grad_index[2];           //è¾“å…¥de/dtéš¶å±åº¦åœ¨è§„åˆ™è¡¨çš„ç´¢å¼•
  53          float KpgradSums[7] = { 0,0,0,0,0,0,0 };   //è¾“å‡ºå¢é‡kpæ€»çš„éš¶å±åº¦
  54          float KigradSums[7] = { 0,0,0,0,0,0,0 };   //è¾“å‡ºå¢é‡kiæ€»çš„éš¶å±åº¦
  55          float KdgradSums[7] = { 0,0,0,0,0,0,0 };   //è¾“å‡ºå¢é‡kdæ€»çš„éš¶å±åº¦
  56          
  57          float e_max = 150;      //è¯¯å·®æœ€å¤§å€¼
  58          float e_min = -150;    //è¯¯å·®æœ€å°å€¼
  59          float ec_max = 300;     //è¯¯å·®å˜åŒ–æœ€å¤§å€¼
  60          float ec_min = -300;    //è¯¯å·®å˜åŒ–æœ€å°å€¼
  61          float kp_max = 50;       //æ¯”ä¾‹ç³»æ•° kp ä¸Šé™å€¼
  62          float kp_min = -50;    //æ¯”ä¾‹ç³»æ•° kp ä¸‹é™å€¼
  63          float ki_max = 0.1;     //ç§¯åˆ†ç³»æ•° ki ä¸Šé™å€¼
  64          float ki_min = -0.1;    //ç§¯åˆ†ç³»æ•° ki ä¸‹é™å€¼
  65          float kd_max = 0.01;    //å¾®åˆ†ç³»æ•° kd ä¸Šé™å€¼
  66          float kd_min = -0.01;   //å¾®åˆ†ç³»æ•° kd ä¸‹é™å€¼
  67          float error;        //è¯¯å·®å€¼
  68          float error_c;      //è¯¯å·®å˜åŒ–å€¼
  69          float error_pre = 0;    //ä¸Šä¸€æ¬¡è¯¯å·®å€¼
  70          float error_ppre = 0;   //ä¸Šä¸Šæ¬¡è¯¯å·®å€¼
  71          
  72          
  73          int  Kp_rule_list[7][7] = { {PB,PB,PM,PM,PS,ZO,ZO},        //kpè§„åˆ™è¡¨
  74                       {PB,PB,PM,PS,PS,ZO,NS},
  75                       {PM,PM,PM,PS,ZO,NS,NS},
  76                       {PM,PM,PS,ZO,NS,NM,NM},
  77                       {PS,PS,ZO,NS,NS,NM,NM},
  78                       {PS,ZO,NS,NM,NM,NM,NB},
  79                       {ZO,ZO,NM,NM,NM,NB,NB} };
  80          
  81          int  Ki_rule_list[7][7] = { {NB,NB,NM,NM,NS,ZO,ZO},     //kiè§„åˆ™è¡¨
  82                      {NB,NB,NM,NS,NS,ZO,ZO},
  83                      {NB,NM,NS,NS,ZO,PS,PS},
  84                      {NM,NM,NS,ZO,PS,PM,PM},
  85                      {NM,NS,ZO,PS,PS,PM,PB},
  86                      {ZO,ZO,PS,PS,PM,PB,PB},
  87                      {ZO,ZO,PS,PM,PM,PB,PB} };
  88          
  89            int  Kd_rule_list[7][7] = { {PS,NS,NB,NB,NB,NM,PS},     //kdè§„åˆ™è¡¨
  90                       {PS,NS,NB,NM,NM,NS,ZO},
  91                       {ZO,NS,NM,NM,NS,NS,ZO},
  92                       {ZO,NS,NS,NS,NS,NS,ZO},
  93                       {ZO,ZO,ZO,ZO,ZO,ZO,ZO},
  94                                     {PB,NS,PS,PS,PS,PS,PB},
  95                                     {PB,PM,PM,PM,PS,PS,PB} };
  96          
  97          void FuzzyPID()  //å‚æ•°åˆå§‹åŒ–
  98          {
  99   1        kp = 0;
 100   1        ki = 0;
 101   1        kd = 0;
 102   1        qdetail_kp = 0;
 103   1        qdetail_ki = 0;
 104   1        qdetail_kd = 0;
 105   1      }
 106          
 107          //æ¨¡ç³ŠPIDæ§åˆ¶å®ç°å‡½æ•°
 108          float FuzzyPIDcontroller(float e_max, float e_min, float ec_max, float ec_min, float kp_max, float kp_min,
             - float error, float error_c,float ki_max,float ki_min,float kd_max,float kd_min,float error_pre,float error_ppre)
 109          {
 110   1        float output;
 111   1        qerror = Quantization(e_max, e_min, error);    //å°† è¯¯å·® error æ˜ å°„åˆ°è®ºåŸŸä¸­
 112   1        qerror_c = Quantization(ec_max, ec_min, error_c);   //å°†è¯¯å·®å˜åŒ– error_c æ˜ å°„åˆ°è®ºåŸŸä¸­
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 3   

 113   1        Get_grad_membership(qerror, qerror_c);  //è®¡ç®—è¯¯å·® error å’Œè¯¯å·®å˜åŒ– error_c çš„éš¶å±åº¦
 114   1        GetSumGrad(); //è®¡ç®—è¾“å‡ºå¢é‡ â–³kpã€â–³kiã€â–³kd çš„æ€»éš¶å±åº¦
 115   1        GetOUT();   // è®¡ç®—è¾“å‡ºå¢é‡ â–³kpã€â–³kiã€â–³kd å¯¹åº”è®ºåŸŸå€¼
 116   1        detail_kp = Inverse_quantization(kp_max, kp_min, qdetail_kp);    //å»æ¨¡ç³ŠåŒ–å¾—åˆ°å¢é‡ â–³kp
 117   1        detail_ki = Inverse_quantization(ki_max, ki_min, qdetail_ki);    //å»æ¨¡ç³ŠåŒ–å¾—åˆ°å¢é‡ â–³ki
 118   1        detail_kd = Inverse_quantization(kd_max, kd_min, qdetail_kd);    //å»æ¨¡ç³ŠåŒ–å¾—åˆ°å¢é‡ â–³kd
 119   1        qdetail_kd = 0;
 120   1        qdetail_ki = 0;
 121   1        qdetail_kp = 0;
 122   1        kp = kp + detail_kp;    //å¾—åˆ°æœ€ç»ˆçš„ kp å€¼
 123   1        ki = ki + detail_ki;    //å¾—åˆ°æœ€ç»ˆçš„ ki å€¼
 124   1        kd = kd + detail_kd;    //å¾—åˆ°æœ€ç»ˆçš„ kd å€¼
 125   1        if (kp < 0){
 126   2          kp = 0;}
 127   1        if (ki < 0){
 128   2          ki = 0;}
 129   1        if (kd < 0){
 130   2          kd = 0;}
 131   1        detail_kp = 0;
 132   1        detail_ki = 0;
 133   1        detail_kd = 0;
 134   1        output = kp*(error - error_pre) + ki * error + kd * (error - 2 * error_pre + error_ppre);   //è®¡ç®—æœ€ç
             -»ˆçš„è¾“å‡º
 135   1        return output;
 136   1      }
 137          
 138           
 139          ///åŒºé—´æ˜ å°„å‡½æ•°
 140          float Quantization(float maximum,float minimum,float x)
 141          {
 142   1        float qvalues= 6.0 *(x-minimum)/(maximum - minimum)-3;
 143   1        return qvalues;
 144   1      }
 145           
 146          //è¾“å…¥eä¸de/dtéš¶å±åº¦è®¡ç®—å‡½æ•°
 147          void Get_grad_membership(float error,float error_c)   
 148          {
 149   1        int i;
 150   1        if (error > e_membership_values[0] && error < e_membership_values[6])
 151   1        {
 152   2          for ( i = 0; i < num_area - 2; i++)
 153   2          {
 154   3            if (error >= e_membership_values[i] && error <= e_membership_values[i + 1])
 155   3            {
 156   4              e_gradmembership[0] = -(error - e_membership_values[i + 1]) / (e_membership_values[i + 1] - e_membersh
             -ip_values[i]);
 157   4              e_gradmembership[1] = 1+(error - e_membership_values[i + 1]) / (e_membership_values[i + 1] - e_members
             -hip_values[i]);
 158   4              e_grad_index[0] = i;
 159   4              e_grad_index[1] = i + 1;
 160   4              break;
 161   4            }
 162   3          }
 163   2        }
 164   1        else
 165   1        {
 166   2          if (error <= e_membership_values[0])
 167   2          {
 168   3            e_gradmembership[0] = 1;
 169   3            e_gradmembership[1] = 0;
 170   3            e_grad_index[0] = 0;
 171   3            e_grad_index[1] = -1;
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 4   

 172   3          }
 173   2          else if (error >= e_membership_values[6])
 174   2          {
 175   3            e_gradmembership[0] = 1;
 176   3            e_gradmembership[1] = 0;
 177   3            e_grad_index[0] = 6;
 178   3            e_grad_index[1] = -1;
 179   3          }
 180   2        }
 181   1       
 182   1        if (error_c > ec_membership_values[0] && error_c < ec_membership_values[6])
 183   1        {
 184   2          for ( i = 0; i < num_area - 2; i++)
 185   2          {
 186   3            if (error_c >= ec_membership_values[i] && error_c <= ec_membership_values[i + 1])
 187   3            {
 188   4              ec_gradmembership[0] = -(error_c - ec_membership_values[i + 1]) / (ec_membership_values[i + 1] - ec_me
             -mbership_values[i]);
 189   4              ec_gradmembership[1] = 1 + (error_c - ec_membership_values[i + 1]) / (ec_membership_values[i + 1] - ec
             -_membership_values[i]);
 190   4              ec_grad_index[0] = i;
 191   4              ec_grad_index[1] = i + 1;
 192   4              break;
 193   4            }
 194   3          }
 195   2        }
 196   1        else
 197   1        {
 198   2          if (error_c <= ec_membership_values[0])
 199   2          {
 200   3            ec_gradmembership[0] = 1;
 201   3            ec_gradmembership[1] = 0;
 202   3            ec_grad_index[0] = 0;
 203   3            ec_grad_index[1] = -1;
 204   3          }
 205   2          else if (error_c >= ec_membership_values[6])
 206   2          {
 207   3            ec_gradmembership[0] = 1;
 208   3            ec_gradmembership[1] = 0;
 209   3            ec_grad_index[0] = 6;
 210   3            ec_grad_index[1] = -1;
 211   3          }
 212   2        }
 213   1       
 214   1      }
 215           
 216          // è·å–è¾“å‡ºå¢é‡kp,ki,kdçš„æ€»éš¶å±åº¦
 217          void GetSumGrad()
 218          {
 219   1        int i;
 220   1        int j;
 221   1      
 222   1          // åˆå§‹åŒ– Kpã€Kiã€Kd æ€»çš„éš¶å±åº¦å€¼ä¸º 0
 223   1                      
 224   1        for ( i = 0; i <= num_area - 1; i++)
 225   1        {
 226   2          KpgradSums[i] = 0;
 227   2          KigradSums[i] = 0;
 228   2                  KdgradSums[i] = 0;
 229   2        }
 230   1      
 231   1            for ( i = 0; i < 2; i++)
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 5   

 232   1           {
 233   2                  if (e_grad_index[i] == -1)
 234   2                  {
 235   3                        continue;
 236   3                }
 237   2                  for ( j = 0; j < 2; j++)
 238   2                {
 239   3                        if (ec_grad_index[j] != -1)
 240   3                        {
 241   4                            int indexKp = Kp_rule_list[e_grad_index[i]][ec_grad_index[j]] + 3;
 242   4                            int indexKi = Ki_rule_list[e_grad_index[i]][ec_grad_index[j]] + 3;
 243   4                            int indexKd = Kd_rule_list[e_grad_index[i]][ec_grad_index[j]] + 3;
 244   4                            KpgradSums[indexKp]= KpgradSums[indexKp] + (e_gradmembership[i] * ec_gradmembership[j])
             -;
 245   4                            KigradSums[indexKi] = KigradSums[indexKi] + (e_gradmembership[i] * ec_gradmembership[j]
             -);
 246   4                            KdgradSums[indexKd] = KdgradSums[indexKd] + (e_gradmembership[i] * ec_gradmembership[j]
             -);
 247   4                        }
 248   3                        else
 249   3                        {
 250   4                            continue;
 251   4                        }
 252   3                  }
 253   2         }
 254   1      }
 255           
 256          // è®¡ç®—è¾“å‡ºå¢é‡kp,kd,kiå¯¹åº”è®ºåŸŸå€¼
 257          void GetOUT()
 258          {
 259   1        int i;
 260   1        for ( i = 0; i < num_area - 1; i++)
 261   1        {
 262   2          qdetail_kp += kp_menbership_values[i] * KpgradSums[i];
 263   2          qdetail_ki += ki_menbership_values[i] * KigradSums[i];
 264   2          qdetail_kd += kd_menbership_values[i] * KdgradSums[i];
 265   2        }
 266   1      }
 267           
 268          //ååŒºé—´æ˜ å°„å‡½æ•°
 269          float Inverse_quantization(float maximum, float minimum, float qvalues)
 270          {
 271   1        float x = (maximum - minimum) *(qvalues + 3)/6 + minimum;
 272   1        return x;
 273   1      }
 274          // Timers value
 275          unsigned int  timer0_value;
 276          unsigned int  timer1_value;
 277          unsigned int  timer2_value;
 278          unsigned int  timer3_value;
 279          unsigned int  timer4_value;
 280          
 281          // ADC & DAC variables
 282          unsigned char channel;   // ADC é€šé“è½¬æ¢
 283          unsigned int  vref;      // VREF
 284          unsigned int  vtarget;   // VTARGET
 285          unsigned int  vadc;      // ADC å–å€¼
 286          unsigned int  vadc_dec;  // ADC å–å€¼
 287          unsigned int  vdac;      // DAC è¾“å‡º
 288          unsigned int  vdac_dec;  // DAC è¾“å‡º
 289          
 290          
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 6   

 291          
 292          
 293          
 294          //ç”¨æˆ·åˆå§‹åŒ–ä»£ç 
 295          uchar code str0[]="PIDCONTROL";
 296          uchar code str1[]="accruate";
 297          uchar code str2[]="Press 1 to start";
 298          uchar code str3[]="Press 3 to back";
 299          
 300          typedef struct{
 301            int setpoint; 
 302            long sumerror;      
 303            float P;      
 304            float I;      
 305            float D;  
 306            int lasterror;  
 307            int preverror;
 308            int result;
 309          }PID;
 310          
 311          PID tmp_pid={0,0,0,0,0,0,0,0};
 312          const unsigned char code blank[1024] = { /* 0X00,0X01,0X80,0X00,0X40,0X00, */
 313          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 314          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 315          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 316          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 317          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 318          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 319          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 320          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 321          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 322          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 323          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 324          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 325          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 326          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 327          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 328          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 329          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 330          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 331          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 332          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 333          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 334          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 335          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 336          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 337          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 338          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 339          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 340          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 341          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 342          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 343          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 344          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 345          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 346          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 347          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 348          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 349          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 350          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 351          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 352          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 7   

 353          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 354          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 355          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 356          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 357          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 358          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 359          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 360          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 361          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 362          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 363          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 364          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 365          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 366          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 367          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 368          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 369          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 370          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 371          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 372          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 373          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 374          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 375          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 376          0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,0X00,
 377          };
 378          
 379          volatile int wave[128]={0};
 380          
 381          unsigned int KEY_FLAG;
 382          
 383          
 384          //ç”¨æˆ·åˆå§‹åŒ–ä»£ç 
 385          void PID_init(PID* ptr)
 386          {
 387   1        ptr->setpoint = 3000;
 388   1        ptr->sumerror = 0; 
 389   1        ptr->lasterror = 0;
 390   1        ptr->preverror = 0; 
 391   1        ptr->P = 1;                
 392   1        ptr->I = 0.025;                
 393   1        ptr->D = 0.004;   
 394   1        ptr->result = 0;                                            
 395   1      }
 396          
 397          
 398          void PID_contrl(PID* ptr,int nowpoint){
 399   1        int tmp_error;
 400   1        int tmp_common;
 401   1        tmp_error = ptr->setpoint - nowpoint; 
 402   1        ptr->sumerror+=tmp_error;
 403   1        tmp_common=tmp_error-ptr->lasterror;
 404   1        ptr->result=FuzzyPIDcontroller(2000, -2000,500, -500, 50, -50, tmp_error, tmp_common, 0.1,-0.1,0.01, -0.0
             -1,ptr->lasterror, ptr->preverror);
 405   1        ptr->preverror=ptr->lasterror;
 406   1        ptr->lasterror = tmp_error;   
 407   1      }
 408          
 409          void PID_display(){
 410   1            WriteStr(0, 0, str0);
 411   1            WriteStr(1, 0, str1);
 412   1            WriteStr(2, 0, str2);
 413   1            WriteStr(3, 0, str3);
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 8   

 414   1      }
 415          
 416          //User end
 417          
 418          void Timer1_Init_Main(void) {
 419   1          Enable_Timer1;       // è®¾å®š IE æ ‡å¿—ä½ 1ï¼Œå…è®¸ Timer1 æº¢å‡ºä¸­æ–­è¯·æ±‚
 420   1          Timer1_Set_Method1;  // è®¾ç½®å®šæ—¶å™¨ 1 ä¸ºæ–¹å¼ 1 å®šæ—¶å™¨åŠŸèƒ½
 421   1      }
 422          
 423          void Timer1_ISR(void) interrupt 3 {
 424   1          timer1_value++;
 425   1      
 426   1          TH1 = 0x00; // Reinit Timer0 High register
 427   1          TL1 = 0x00;
 428   1      }
 429          
 430          void Device_Init(void) {
 431   1          SYS_Init();  // SYS åˆå§‹åŒ–
 432   1          LcdInit();
 433   1          LedInit();
 434   1          Timer1_Init_Main();
 435   1          Timer3_Init_ADC0(SYSCLK / SAMPLERATE);  // TIMER3 åˆå§‹åŒ– 
 436   1      
 437   1          INT_Init();  // INT ä¸­æ–­åˆå§‹åŒ–
 438   1      
 439   1          ADC0_Init();     // ADC0 åˆå§‹åŒ–
 440   1          ADC0_Enable(1);  // ä½¿èƒ½ ADC0
 441   1          DAC0_Init();     // DAC åˆå§‹åŒ–
 442   1      
 443   1          Timer1_Start;  // è®¾å®š TCON ä¸­æ–­æ ‡å¿—ä½ 6ï¼Œå®šæ—¶å™¨ 1 å¼€å¯
 444   1      
 445   1          timer1_value = 0;
 446   1          timer3_value = 0;
 447   1      
 448   1          channel  = 1;
 449   1          vref     = 5244;
 450   1          vtarget  = 2800;
 451   1          vadc     = 0x0000;
 452   1          vadc_dec = 0;
 453   1          vdac     = 0x0000;
 454   1          vdac_dec = 0;
 455   1      }
 456          
 457          void Do(void) {
 458   1          if ((timer1_value & 0x0007) == 0x0001) {     
 459   2              if (channel == 1)    {
 460   3                  // ä» ADC0 AIN1 å–å¾— 10 ä½ 16 è¿›åˆ¶æ•° vadc
 461   3                  vadc = ADC_ValueReturn(channel);
 462   3                  // å°† vadc è½¬åŒ–ä¸º 10 è¿›åˆ¶æ•°è¿›è¡Œè®¡ç®—
 463   3                  vadc_dec = (unsigned long int)vadc * (unsigned long int)vref / 4096;
 464   3                  PID_contrl(&tmp_pid,vadc_dec);
 465   3                  vdac_dec=vadc_dec+tmp_pid.result;
 466   3                  // å°† 10 è¿›åˆ¶æ•° vdac_dec è½¬åŒ–ä¸º 16 è¿›åˆ¶æ•°
 467   3                  vdac = (unsigned long int)vdac_dec * 4096 / (unsigned long int)vref;
 468   3                  // ä» ADC0 è¾“å‡º 10 ä½ 16 è¿›åˆ¶æ•° vdac
 469   3                  DAC0_Output(vdac);
 470   3                //è°ƒèŠ‚ç›®æ ‡éœå°”ç”µå‹å€¼
 471   3                if(KEY_FLAG==1){
 472   4                  tmp_pid.setpoint-=100;
 473   4                  KEY_FLAG=0;}
 474   3                else{
 475   4                  if(KEY_FLAG==2){
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 9   

 476   5                  tmp_pid.setpoint+=100;
 477   5                  KEY_FLAG=0;}
 478   4                }
 479   3            }
 480   2          }
 481   1        }
 482          int main(void) {
 483   1          int i=0,j=0;
 484   1          Device_Init();
 485   1          PID_init(&tmp_pid);
 486   1          while (1) {
 487   2          my_LedDispNum(vadc_dec,tmp_pid.setpoint,vdac_dec);
 488   2          PID_display();
 489   2          if(KEY_FLAG==1){
 490   3          LcdClear();
 491   3          ImageShow(blank);
 492   3          KEY_FLAG=0;
 493   3          while(KEY_FLAG!=3){
 494   4            my_LedDispNum(vadc_dec,tmp_pid.setpoint,vdac_dec);
 495   4            Do();
 496   4            i+=1;
 497   4            if(i%5==0){
 498   5              wave[j]=vadc_dec;
 499   5              LcdShowPoint(j);
 500   5              i=0;
 501   5              j+=1;
 502   5              if(j==128){
 503   6                ImageShow(blank);
 504   6                j=0;
 505   6                }
 506   5              }
 507   4            }
 508   3            vdac=0;
 509   3            DAC0_Output(vdac);
 510   3            KEY_FLAG=0;
 511   3            LcdInit();
 512   3            }
 513   2          }
 514   1      }
 515          
 516          void INT1_ISR(void) interrupt 2
 517          {
 518   1        Delay_ms(20);
 519   1        switch(P5){
 520   2          case 0xfb:
 521   2            KEY_FLAG=1;
 522   2            break;    
 523   2          case 0xfd:
 524   2            KEY_FLAG=2;
 525   2            break;
 526   2          case 0xfe:
 527   2            KEY_FLAG=3;
 528   2            break;
 529   2        }
 530   1      }
 531          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5333    ----
   CONSTANT SIZE    =   1077    ----
   XDATA SIZE       =    949     113
C51 COMPILER V9.52.0.0   MAIN                                                              04/20/2022 22:04:09 PAGE 10  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
